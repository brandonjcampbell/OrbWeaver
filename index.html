<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Neo4j Node Explorer</title>
  <style>
    :root {
      color-scheme: light;
      font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background-color: #f2f8ed;
      color: #12391c;
      --color-surface: rgba(244, 255, 230, 0.92);
      --color-surface-strong: rgba(236, 252, 214, 0.94);
      --color-border: rgba(30, 97, 43, 0.14);
      --color-primary: #1f612b;
      --color-primary-dark: #16471f;
      --color-accent: #7ddc4b;
      --color-accent-dark: #63c135;
      --color-muted: rgba(18, 67, 32, 0.78);
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      background: linear-gradient(180deg, #f1f7ee 0%, #ffffff 60%);
    }

    header {
      background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
      color: #f3ffe5;
      padding: 1.5rem clamp(1.5rem, 4vw, 3rem);
      box-shadow: 0 12px 32px rgba(18, 67, 32, 0.28);
      display: flex;
      align-items: center;
      gap: clamp(1rem, 2.5vw, 1.75rem);
    }

    .logo {
      width: clamp(60px, 12vw, 84px);
      height: auto;
      filter: drop-shadow(0 14px 30px rgba(17, 58, 30, 0.3));
      flex-shrink: 0;
    }

    .heading {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.5rem, 4vw, 1.85rem);
      letter-spacing: 0.02em;
    }

    header p {
      margin: 0;
      font-size: 0.95rem;
      color: rgba(243, 255, 229, 0.82);
    }

    main {
      flex: 1;
      padding: 2rem clamp(1rem, 4vw, 3rem);
      display: flex;
      flex-direction: column;
      gap: 1.75rem;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
      padding: 1rem 1.5rem;
      border-radius: 14px;
      background: var(--color-surface);
      backdrop-filter: blur(6px);
      box-shadow: 0 18px 40px rgba(19, 71, 34, 0.14);
      border: 1px solid var(--color-border);
    }

    .hop-control {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.95rem;
      color: var(--color-primary-dark);
    }

    .hop-control label {
      font-weight: 600;
    }

    .hop-control input[type="number"] {
      width: 4.5rem;
      padding: 0.3rem 0.5rem;
      border-radius: 999px;
      border: 1px solid var(--color-border);
      background: rgba(255, 255, 255, 0.9);
      font: inherit;
      text-align: center;
      color: inherit;
    }

    .hop-control input[type="number"]:focus {
      outline: 2px solid var(--color-accent);
      outline-offset: 2px;
    }

    .hop-control__summary {
      font-size: 0.85rem;
      color: var(--color-muted);
      white-space: nowrap;
    }

    button {
      border: none;
      background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-dark) 100%);
      color: #0f2f14;
      font-weight: 600;
      font-size: 0.95rem;
      letter-spacing: 0.02em;
      padding: 0.65rem 1.3rem;
      border-radius: 999px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      box-shadow: 0 12px 20px rgba(35, 109, 55, 0.22);
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 16px 28px rgba(35, 109, 55, 0.28);
      background: linear-gradient(135deg, var(--color-accent-dark) 0%, #55ad2c 100%);
    }

    button:disabled {
      cursor: wait;
      opacity: 0.7;
      box-shadow: none;
    }

    #status {
      font-size: 0.95rem;
      flex: 1 1 16rem;
      color: var(--color-muted);
    }

    #status.error {
      color: #c0392b;
      font-weight: 600;
    }

    .table-wrapper {
      position: relative;
      flex: 1;
      overflow: hidden;
      border-radius: 18px;
      background: var(--color-surface-strong);
      box-shadow: 0 20px 50px rgba(23, 72, 38, 0.18);
      border: 1px solid var(--color-border);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.95rem;
    }

    thead {
      background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
      color: #f6ffe9;
    }

    th,
    td {
      padding: 0.85rem 1rem;
      vertical-align: top;
      border-bottom: 1px solid rgba(31, 97, 43, 0.14);
    }

    tbody tr:nth-child(odd) {
      background: rgba(125, 220, 75, 0.08);
    }

    tbody tr:hover {
      background: rgba(125, 220, 75, 0.16);
    }

    tbody tr[data-action="inspect"] {
      cursor: pointer;
      transition: background-color 0.18s ease, transform 0.18s ease;
    }

    tbody tr[data-action="inspect"]:hover {
      transform: translateX(2px);
    }

    tbody tr[data-action="inspect"]:focus-visible {
      outline: 2px solid var(--color-accent);
      outline-offset: -2px;
    }

    .properties {
      font-family: "Fira Code", "Source Code Pro", Menlo, monospace;
      font-size: 0.85rem;
      white-space: pre-wrap;
      word-break: break-word;
      background: rgba(30, 97, 43, 0.08);
      border-radius: 8px;
      padding: 0.65rem 0.75rem;
      margin: 0;
    }

    .empty-state {
      padding: 2rem;
      text-align: center;
      color: rgba(18, 67, 32, 0.68);
    }

    .graph-section {
      padding: 1.5rem clamp(1.2rem, 3vw, 2.25rem);
      border-radius: 18px;
      background: var(--color-surface-strong);
      box-shadow: 0 20px 50px rgba(23, 72, 38, 0.18);
      border: 1px solid var(--color-border);
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
      min-height: 420px;
    }

    .graph-header {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      justify-content: space-between;
      gap: 0.75rem 1.5rem;
    }

    .graph-header h2 {
      margin: 0;
      font-size: clamp(1.1rem, 3vw, 1.35rem);
      letter-spacing: 0.01em;
      color: var(--color-primary-dark);
    }

    #graphStatus {
      font-size: 0.95rem;
      color: var(--color-muted);
    }

    #graphStatus.error {
      color: #c0392b;
      font-weight: 600;
    }

    .graph-body {
      display: flex;
      flex-wrap: wrap;
      gap: clamp(1rem, 2.5vw, 1.6rem);
      align-items: stretch;
    }

    .graph-container {
      flex: 1 1 clamp(320px, 55%, 520px);
      min-height: clamp(320px, 45vh, 540px);
      border-radius: 16px;
      border: 1px dashed rgba(31, 97, 43, 0.24);
      background: rgba(244, 255, 230, 0.58);
      position: relative;
      overflow: hidden;
    }

    .graph-container svg {
      width: 100%;
      height: 100%;
      font-family: "Fira Code", "Source Code Pro", Menlo, monospace;
    }

    .graph-details {
      flex: 1 1 260px;
      min-width: min(280px, 100%);
      background: rgba(255, 255, 255, 0.74);
      border-radius: 16px;
      border: 1px solid var(--color-border);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6), 0 18px 32px rgba(23, 72, 38, 0.12);
      padding: clamp(1rem, 2.4vw, 1.5rem);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .graph-details h3 {
      margin: 0;
      font-size: clamp(0.95rem, 2.5vw, 1.1rem);
      letter-spacing: 0.03em;
      color: var(--color-primary-dark);
    }

    .graph-details__content {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
    }

    .graph-details__name {
      margin: 0;
      font-size: clamp(1rem, 2.4vw, 1.2rem);
      font-weight: 600;
      color: var(--color-primary);
      letter-spacing: 0.01em;
    }

    .graph-details__list {
      margin: 0;
      display: grid;
      gap: 0.85rem;
    }

    .graph-details__list dt {
      margin: 0;
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(18, 67, 32, 0.58);
    }

    .graph-details__list dd {
      margin: 0;
      font-size: 0.9rem;
      color: var(--color-muted);
      line-height: 1.5;
    }

    .graph-details__list code {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 6px;
      background: rgba(30, 97, 43, 0.08);
      font-size: 0.85rem;
    }

    .graph-details__content .properties {
      margin: 0;
    }

    .graph-details__empty {
      margin: 0;
      font-size: 0.92rem;
      color: rgba(18, 67, 32, 0.68);
      line-height: 1.5;
    }

    .graph-link {
      stroke: rgba(24, 84, 33, 0.32);
      stroke-width: 1.6px;
      stroke-linecap: round;
    }

    .graph-link-label {
      fill: var(--color-primary-dark);
      font-size: 0.68rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
      paint-order: stroke;
      stroke: rgba(255, 255, 255, 0.82);
      stroke-width: 4px;
      stroke-linejoin: round;
      text-shadow: 0 1px 2px rgba(18, 67, 32, 0.12);
    }

    .graph-node circle {
      fill: var(--color-primary);
      stroke: rgba(255, 255, 255, 0.9);
      stroke-width: 2.2px;
      filter: drop-shadow(0 12px 24px rgba(21, 74, 33, 0.28));
      transition: transform 0.2s ease, fill 0.2s ease;
    }

    .graph-node text {
      fill: #f6ffe9;
      font-size: 0.7rem;
      pointer-events: none;
      text-anchor: middle;
      paint-order: stroke;
      stroke: rgba(18, 67, 32, 0.35);
      stroke-width: 2px;
      stroke-linejoin: round;
    }

    .graph-node:hover circle,
    .graph-node:focus-visible circle {
      fill: var(--color-accent-dark);
    }

    .graph-node--expanded circle {
      fill: #2a7b3c;
    }

    .graph-node--active circle {
      fill: var(--color-accent);
    }

    @media (max-width: 720px) {
      header {
        flex-direction: column;
        align-items: flex-start;
        padding: 1.5rem clamp(1rem, 6vw, 2rem);
      }

      .logo {
        width: clamp(54px, 18vw, 72px);
      }

      header h1 {
        font-size: 1.45rem;
      }

      table {
        font-size: 0.85rem;
      }

      th,
      td {
        padding: 0.65rem 0.75rem;
      }

      .graph-section {
        padding: 1.25rem;
      }

      .graph-body {
        flex-direction: column;
      }

      .graph-container {
        min-height: clamp(300px, 50vh, 520px);
      }

      .graph-details {
        min-width: 0;
      }
    }
  </style>
</head>
<body>
  <header>
    <img class="logo" src="orbWeaver.png" alt="Orb Weaver logo" />
    <div class="heading">
      <h1>Neo4j Node Explorer</h1>
      <p>Connected to Aura instance <strong>Instance02</strong> (<code>885f2ada</code>)</p>
    </div>
  </header>

  <main>
    <section class="controls">
      <button id="reload">Reload nodes</button>
      <div class="hop-control">
        <label for="hopLimit">Visible hops</label>
        <input
          type="number"
          id="hopLimit"
          name="hopLimit"
          min="0"
          step="1"
          value="2"
          aria-describedby="hopLimitSummary"
        />
        <span id="hopLimitSummary" class="hop-control__summary" aria-live="polite">Up to 2 hops</span>
      </div>
      <div id="status" role="status" aria-live="polite">Ready to connect.</div>
    </section>

    <section class="graph-section" aria-label="Graph explorer">
      <div class="graph-header">
        <h2>Graph explorer</h2>
        <div id="graphStatus" role="status" aria-live="polite">
          Select a node from the table to explore its relationships.
        </div>
      </div>
      <div class="graph-body">
        <div
          id="graphContainer"
          class="graph-container"
          role="application"
          aria-label="Interactive graph visualization"
        ></div>
        <aside class="graph-details" aria-labelledby="nodeDetailsTitle">
          <h3 id="nodeDetailsTitle">Node metadata</h3>
          <div
            id="nodeDetails"
            class="graph-details__content"
            role="status"
            aria-live="polite"
          >
            <p class="graph-details__empty">
              Select a node from the table or graph to view its metadata.
            </p>
          </div>
        </aside>
      </div>
    </section>

    <section class="table-wrapper" aria-live="polite">
      <table>
        <thead>
          <tr>
            <th scope="col">#</th>
            <th scope="col">Element ID</th>
            <th scope="col">Labels</th>
            <th scope="col">Properties</th>
          </tr>
        </thead>
        <tbody id="nodesBody">
          <tr class="empty-state">
            <td colspan="4">Click "Reload nodes" to view the first 100 nodes in the database.</td>
          </tr>
        </tbody>
      </table>
    </section>
  </main>

  <script
    src="https://cdn.jsdelivr.net/npm/neo4j-driver-lite@5.13.0/lib/browser/neo4j-lite-web.min.js"
    crossorigin="anonymous"
  ></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" crossorigin="anonymous"></script>
  <script>
    (function () {
      "use strict";

      const config = {
        uri: "neo4j+s://d0287b2c.databases.neo4j.io",
        username: "d0287b2c",
        password: "aAq-jgBkY4ADPicyQW2-IQDSgiGLmH9GpPfQFoKUNoA",
        database: "d0287b2c",

      };

      const reloadButton = document.getElementById("reload");
      const statusElement = document.getElementById("status");
      const nodesBody = document.getElementById("nodesBody");
      const graphContainer = document.getElementById("graphContainer");
      const graphStatus = document.getElementById("graphStatus");
      const nodeDetails = document.getElementById("nodeDetails");
      const hopLimitInput = document.getElementById("hopLimit");
      const hopLimitSummary = document.getElementById("hopLimitSummary");
      const defaultHopLimit = 2;
      let activeHopLimit = defaultHopLimit;

      const defaultNodeDetailsMessage = "Select a node from the table or graph to view its metadata.";
      let graphExplorer;

      const parseHopLimitValue = (value) => {
        const parsed = Number(value);

        if (!Number.isFinite(parsed) || parsed < 0) {
          return 0;
        }

        return Math.floor(parsed);
      };

      const describeHopLimit = (value) => {
        if (value <= 0) {
          return "Focus only";
        }

        if (value === 1) {
          return "Up to 1 hop";
        }

        return `Up to ${value} hops`;
      };

      const syncHopLimitDisplay = (value) => {
        if (hopLimitInput && hopLimitInput.value !== String(value)) {
          hopLimitInput.value = String(value);
        }

        if (hopLimitSummary) {
          hopLimitSummary.textContent = describeHopLimit(value);
        }
      };

      const updateHopLimit = (value, options = {}) => {
        const sanitized = parseHopLimitValue(value);
        activeHopLimit = sanitized;
        syncHopLimitDisplay(sanitized);

        if (graphExplorer) {
          graphExplorer.setDepthLimit(sanitized, options);
        }

        return sanitized;
      };

      if (hopLimitInput) {
        activeHopLimit = updateHopLimit(hopLimitInput.value || defaultHopLimit, { skipSync: true });
        hopLimitInput.addEventListener("input", (event) => {
          updateHopLimit(event.target.value);
        });
      } else {
        syncHopLimitDisplay(activeHopLimit);
      }

      const setStatus = (message, isError = false) => {
        statusElement.textContent = message;
        statusElement.classList.toggle("error", Boolean(isError));
      };

      const setGraphStatus = (message, isError = false) => {
        graphStatus.textContent = message;
        graphStatus.classList.toggle("error", Boolean(isError));
      };

      const renderNodeDetails = (node, connectionCount = 0, hiddenConnections = 0) => {
        if (!nodeDetails) {
          return;
        }

        nodeDetails.innerHTML = "";

        if (!node) {
          const emptyMessage = document.createElement("p");
          emptyMessage.className = "graph-details__empty";
          emptyMessage.textContent = defaultNodeDetailsMessage;
          nodeDetails.appendChild(emptyMessage);
          return;
        }

        const name = document.createElement("p");
        name.className = "graph-details__name";
        name.textContent = node.displayName || node.elementId || "(unknown node)";
        nodeDetails.appendChild(name);

        const list = document.createElement("dl");
        list.className = "graph-details__list";

        const appendDetail = (label, value) => {
          const term = document.createElement("dt");
          term.textContent = label;

          const description = document.createElement("dd");
          if (value && typeof value === "object" && "nodeType" in value) {
            description.appendChild(value);
          } else {
            description.textContent = String(value);
          }

          list.appendChild(term);
          list.appendChild(description);
        };

        const idCode = document.createElement("code");
        idCode.textContent = node.elementId || "(unknown)";
        appendDetail("Element ID", idCode);

        const labelsText = Array.isArray(node.labels) && node.labels.length ? node.labels.join(", ") : "(no labels)";
        appendDetail("Labels", labelsText);

        appendDetail("Connections in view", connectionCount);

        if (hiddenConnections > 0) {
          appendDetail(
            "Hidden beyond hop limit",
            `${hiddenConnections} connection${hiddenConnections === 1 ? "" : "s"}`
          );
        }

        const propertiesPre = document.createElement("pre");
        propertiesPre.className = "properties";
        propertiesPre.textContent = JSON.stringify(node.properties || {}, null, 2);
        appendDetail("Properties", propertiesPre);

        nodeDetails.appendChild(list);
      };

      const setLoading = (isLoading) => {
        reloadButton.disabled = isLoading;
        reloadButton.textContent = isLoading ? "Loading…" : "Reload nodes";
      };

      const clearTable = () => {
        while (nodesBody.firstChild) {
          nodesBody.removeChild(nodesBody.firstChild);
        }
      };

      const renderEmptyState = () => {
        const row = document.createElement("tr");
        row.className = "empty-state";
        const cell = document.createElement("td");
        cell.colSpan = 4;
        cell.textContent = "No nodes were returned by the query.";
        row.appendChild(cell);
        nodesBody.appendChild(row);
      };

      const formatNode = (node) => {
        if (!node) {
          throw new Error("Unable to format an undefined node.");
        }

        const rawElementId = typeof node.elementId === "function" ? node.elementId() : node.elementId;
        const identity = node.identity && typeof node.identity.toString === "function" ? node.identity.toString() : node.identity;
        const id = String(rawElementId || identity || node.id || Math.random().toString(36).slice(2));
        const labels = Array.isArray(node.labels) ? [...node.labels] : [];
        const properties = node.properties && typeof node.properties === "object" ? { ...node.properties } : {};

        const displayName =
          node.displayName ||
          properties.name ||
          properties.title ||
          properties.fullName ||
          properties.displayName ||
          properties.id ||
          properties.uid ||
          (labels.length ? labels[0] : null) ||
          id;

        const tooltipParts = [`ID: ${id}`];
        if (labels.length) {
          tooltipParts.push(`Labels: ${labels.join(", ")}`);
        }
        if (Object.keys(properties).length) {
          tooltipParts.push(`Properties:\n${JSON.stringify(properties, null, 2)}`);
        }

        return {
          id,
          elementId: id,
          labels,
          properties,
          displayName,
          tooltip: tooltipParts.join("\n"),
        };
      };

      const formatRelationshipType = (type) => {
        if (!type) {
          return "RELATED";
        }

        const formatted = String(type).replace(/_/g, " ").trim();
        return formatted || "RELATED";
      };

      const renderNodes = (records) => {
        clearTable();

        if (!records.length) {
          renderEmptyState();
          return;
        }

        let firstFocusableRow = null;

        records.forEach((record, index) => {
          const node = record.get("n");
          const formattedNode = formatNode(node);
          const row = document.createElement("tr");
          row.dataset.action = "inspect";
          row.dataset.elementId = formattedNode.elementId;
          row.tabIndex = 0;
          row.setAttribute("role", "button");

          if (index === 0) {
            firstFocusableRow = row;
          }

          const indexCell = document.createElement("td");
          indexCell.textContent = String(index + 1);
          row.appendChild(indexCell);

          const idCell = document.createElement("td");
          idCell.textContent = formattedNode.elementId || "(unknown)";
          row.appendChild(idCell);

          const labelsCell = document.createElement("td");
          labelsCell.textContent = formattedNode.labels.length ? formattedNode.labels.join(", ") : "(no labels)";
          row.appendChild(labelsCell);

          const propertiesCell = document.createElement("td");
          const pre = document.createElement("pre");
          pre.className = "properties";
          pre.textContent = JSON.stringify(formattedNode.properties || {}, null, 2);
          propertiesCell.appendChild(pre);
          row.appendChild(propertiesCell);

          row.__neo4jNode = node;

          const activateRow = () => {
            openGraphWithRoot(row.__neo4jNode, formattedNode.displayName);
          };

          row.addEventListener("click", activateRow);
          row.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              activateRow();
            }
          });

          nodesBody.appendChild(row);
        });

        if (firstFocusableRow && typeof firstFocusableRow.focus === "function") {
          const focusRow = () => {
            try {
              firstFocusableRow.focus({ preventScroll: true });
            } catch (error) {
              firstFocusableRow.focus();
            }
          };

          if (typeof requestAnimationFrame === "function") {
            requestAnimationFrame(() => {
              focusRow();
            });
          } else {
            setTimeout(focusRow, 0);
          }
        }
      };

      const getNeo4jDriver = () => {
        const neo4jGlobal = window.neo4j || window.neo4jLite || window.neo4jDriver;

        if (!neo4jGlobal) {
          throw new Error(
            "Neo4j JavaScript driver failed to load. Check your network connection and script tag."
          );
        }

        return neo4jGlobal;
      };

      const getD3 = () => {
        const d3Global = window.d3;

        if (!d3Global) {
          throw new Error(
            "D3.js failed to load. Ensure the D3 script is available and the network connection is active."
          );
        }

        return d3Global;
      };

      const d3Instance = getD3();

      const runNeo4jQuery = async (query, params = {}) => {
        const neo4j = getNeo4jDriver();

        let driver;
        let session;

        try {
          driver = neo4j.driver(
            config.uri,
            neo4j.auth.basic(config.username, config.password),
            {
              disableLosslessIntegers: true,
              connectionTimeout: 15000,
            }
          );

          session = driver.session({ database: config.database });
          return await session.run(query, params);
        } finally {
          if (session) {
            session.close().catch(() => {});
          }
          if (driver) {
            driver.close().catch(() => {});
          }
        }
      };

      class GraphExplorer {
        constructor(container) {
          const d3 = d3Instance;

          this.container = container;
          this.d3 = d3;
          this.nodes = [];
          this.links = [];
          this.nodeIndex = new Map();
          this.linkIndex = new Map();
          this.loadedNodes = new Set();
          this.activeNodeId = null;
          this.focusNodeId = null;
          this.depthLimit = Infinity;
          this.nodeDepths = new Map();

          const bounds = container.getBoundingClientRect();
          this.width = bounds.width || container.clientWidth || 640;
          this.height = bounds.height || container.clientHeight || 480;

          this.svg = d3
            .select(container)
            .append("svg")
            .attr("viewBox", `0 0 ${this.width} ${this.height}`)
            .attr("preserveAspectRatio", "xMidYMid meet");

          this.linkGroup = this.svg.append("g");
          this.labelGroup = this.svg.append("g");
          this.nodeGroup = this.svg.append("g");

          this.simulation = d3
            .forceSimulation(this.nodes)
            .force(
              "charge",
              d3
                .forceManyBody()
                .strength(-320)
                .distanceMax(Math.max(this.width, this.height))
            )
            .force(
              "link",
              d3
                .forceLink(this.links)
                .id((d) => d.id)
                .distance(140)
                .strength(0.8)
            )
            .force("center", d3.forceCenter(this.width / 2, this.height / 2))
            .force("collision", d3.forceCollide().radius(48));

          this.nodeElements = this.nodeGroup.selectAll(".graph-node");
          this.linkElements = this.linkGroup.selectAll(".graph-link");
          this.linkLabelElements = this.labelGroup.selectAll(".graph-link-label");

          this.dragBehavior = d3
            .drag()
            .on("start", (event, d) => {
              if (!event.active) {
                this.simulation.alphaTarget(0.3).restart();
              }
              d.fx = d.x;
              d.fy = d.y;
            })
            .on("drag", (event, d) => {
              d.fx = event.x;
              d.fy = event.y;
            })
            .on("end", (event, d) => {
              if (!event.active) {
                this.simulation.alphaTarget(0);
              }
              d.fx = null;
              d.fy = null;
            });

          this.simulation.on("tick", () => {
            const width = this.width;
            const height = this.height;

            const resolvePosition = (endpoint) => {
              if (endpoint && typeof endpoint === "object") {
                const xValue =
                  typeof endpoint.x === "number"
                    ? endpoint.x
                    : typeof endpoint.fx === "number"
                    ? endpoint.fx
                    : width / 2;
                const yValue =
                  typeof endpoint.y === "number"
                    ? endpoint.y
                    : typeof endpoint.fy === "number"
                    ? endpoint.fy
                    : height / 2;

                return { x: xValue, y: yValue };
              }

              const node = this.nodeIndex.get(endpoint);

              if (node && typeof node.x === "number" && typeof node.y === "number") {
                return { x: node.x, y: node.y };
              }

              return { x: width / 2, y: height / 2 };
            };

            this.linkElements
              .attr("x1", (d) => (typeof d.source === "object" ? d.source.x : width / 2))
              .attr("y1", (d) => (typeof d.source === "object" ? d.source.y : height / 2))
              .attr("x2", (d) => (typeof d.target === "object" ? d.target.x : width / 2))
              .attr("y2", (d) => (typeof d.target === "object" ? d.target.y : height / 2));

            this.nodeElements.attr("transform", (d) => {
              const x = typeof d.x === "number" ? d.x : width / 2;
              const y = typeof d.y === "number" ? d.y : height / 2;
              return `translate(${x}, ${y})`;
            });

            this.linkLabelElements.attr("transform", (d) => {
              const source = resolvePosition(d.source);
              const target = resolvePosition(d.target);
              const centerX = (source.x + target.x) / 2;
              const centerY = (source.y + target.y) / 2;

              const dx = target.x - source.x;
              const dy = target.y - source.y;
              const length = Math.sqrt(dx * dx + dy * dy) || 1;
              const offset = 14;

              const offsetX = (-dy / length) * offset;
              const offsetY = (dx / length) * offset;

              const x = centerX + offsetX;
              const y = centerY + offsetY;

              return `translate(${x}, ${y})`;
            });
          });

          this.update();
        }

        reset() {
          this.nodes.length = 0;
          this.links.length = 0;
          this.nodeIndex.clear();
          this.linkIndex.clear();
          this.loadedNodes.clear();
          this.activeNodeId = null;
          this.focusNodeId = null;
          this.nodeDepths.clear();
          renderNodeDetails(null);
          this.update();
        }

        addOrUpdateNode(node, options = {}) {
          const existing = this.nodeIndex.get(node.id);

          if (existing) {
            Object.assign(existing, node);
            return existing;
          }

          const nodeCopy = {
            ...node,
            hidden: typeof node.hidden === "boolean" ? node.hidden : false,
            depth: typeof node.depth === "number" ? node.depth : Infinity,
          };
          this.nodeIndex.set(nodeCopy.id, nodeCopy);
          this.nodes.push(nodeCopy);

          if (!options.skipUpdate) {
            this.update();
          }

          return nodeCopy;
        }

        addLink(sourceId, targetId, type, key, options = {}) {
          const linkKey = key || `${sourceId}->${targetId}:${type}`;

          if (this.linkIndex.has(linkKey)) {
            return false;
          }

          const link = {
            key: linkKey,
            source: sourceId,
            target: targetId,
            sourceId,
            targetId,
            type,
            hidden: false,
          };

          this.linkIndex.set(linkKey, link);
          this.links.push(link);

          if (!options.skipUpdate) {
            this.update();
          }

          return true;
        }

        markNodeLoaded(nodeId) {
          this.loadedNodes.add(nodeId);
          this.refreshNodeState();
        }

        isNodeLoaded(nodeId) {
          return this.loadedNodes.has(nodeId);
        }

        getNode(nodeId) {
          if (nodeId == null) {
            return null;
          }

          const id = String(nodeId);
          return this.nodeIndex.get(id) || null;
        }

        getNeighborIds(nodeId, options = {}) {
          if (nodeId == null) {
            return [];
          }

          const includeHidden = Boolean(options.includeHidden);
          const id = String(nodeId);
          const neighbors = new Set();

          this.links.forEach((link) => {
            if (!includeHidden && link.hidden) {
              return;
            }

            const sourceId = this.getNodeIdFromLink(link, "source");
            const targetId = this.getNodeIdFromLink(link, "target");

            if (sourceId === id && targetId) {
              neighbors.add(targetId);
            } else if (targetId === id && sourceId) {
              neighbors.add(sourceId);
            }
          });

          return Array.from(neighbors);
        }

        setActiveNode(nodeId) {
          const activeNode = nodeId ? this.nodeIndex.get(nodeId) : null;

          if (!activeNode) {
            this.activeNodeId = null;
            this.refreshNodeState();
            renderNodeDetails(null);
            return;
          }

          this.activeNodeId = nodeId;
          this.refreshNodeState();
          const visibleConnections = this.countConnections(nodeId);
          const totalConnections = this.countConnections(nodeId, { includeHidden: true });
          const hiddenConnections = Math.max(0, totalConnections - visibleConnections);

          renderNodeDetails(activeNode, visibleConnections, hiddenConnections);
        }

        refreshNodeState() {
          if (!this.nodeElements) {
            return;
          }

          this.nodeElements
            .classed("graph-node--expanded", (d) => this.loadedNodes.has(d.id))
            .classed("graph-node--active", (d) => d.id === this.activeNodeId);
        }

        countConnections(nodeId, options = {}) {
          if (!nodeId) {
            return 0;
          }

          const includeHidden = Boolean(options.includeHidden);

          return this.links.reduce((total, link) => {
            if (!includeHidden && link.hidden) {
              return total;
            }

            const sourceId = this.getNodeIdFromLink(link, "source");
            const targetId = this.getNodeIdFromLink(link, "target");

            return total + (sourceId === nodeId || targetId === nodeId ? 1 : 0);
          }, 0);
        }

        getNodeIdFromLink(link, endpoint) {
          if (!link) {
            return null;
          }

          const endpointValue = link[endpoint];

          if (endpointValue && typeof endpointValue === "object") {
            if (endpointValue.id != null) {
              return String(endpointValue.id);
            }

            if (endpointValue.elementId != null) {
              return String(endpointValue.elementId);
            }
          }

          const fallbackKey = endpoint === "source" ? "sourceId" : "targetId";
          const fallbackValue = link[fallbackKey];

          if (fallbackValue != null) {
            return String(fallbackValue);
          }

          if (typeof endpointValue === "string" || typeof endpointValue === "number") {
            return String(endpointValue);
          }

          return null;
        }

        isNodeHidden(nodeId) {
          if (!nodeId) {
            return false;
          }

          const node = this.nodeIndex.get(nodeId);
          return node ? Boolean(node.hidden) : false;
        }

        recalculateDepths() {
          this.nodeDepths.clear();

          const hasFocus = Boolean(this.focusNodeId && this.nodeIndex.has(this.focusNodeId));

          if (!hasFocus) {
            this.nodes.forEach((node) => {
              node.depth = 0;
              node.hidden = false;
              this.nodeDepths.set(node.id, 0);
            });
            return;
          }

          const focusId = this.focusNodeId;
          this.nodeDepths.set(focusId, 0);

          const adjacency = new Map();

          const registerConnection = (from, to) => {
            if (!adjacency.has(from)) {
              adjacency.set(from, new Set());
            }
            adjacency.get(from).add(to);
          };

          this.links.forEach((link) => {
            const sourceId = this.getNodeIdFromLink(link, "source");
            const targetId = this.getNodeIdFromLink(link, "target");

            if (!sourceId || !targetId) {
              return;
            }

            registerConnection(sourceId, targetId);
            registerConnection(targetId, sourceId);
          });

          const queue = [focusId];
          const visited = new Set(queue);

          while (queue.length) {
            const currentId = queue.shift();
            const currentDepth = this.nodeDepths.get(currentId) ?? 0;
            const neighbors = adjacency.get(currentId);

            if (!neighbors) {
              continue;
            }

            neighbors.forEach((neighborId) => {
              if (visited.has(neighborId)) {
                return;
              }

              visited.add(neighborId);
              this.nodeDepths.set(neighborId, currentDepth + 1);
              queue.push(neighborId);
            });
          }

          this.nodes.forEach((node) => {
            const depth = this.nodeDepths.has(node.id) ? this.nodeDepths.get(node.id) : Infinity;
            this.nodeDepths.set(node.id, depth);
            node.depth = depth;
          });
        }

        applyDepthLimit() {
          const hasFocus = Boolean(this.focusNodeId && this.nodeIndex.has(this.focusNodeId));
          const limit = this.depthLimit;
          const limitIsFinite = Number.isFinite(limit);

          this.nodes.forEach((node) => {
            if (!hasFocus || !limitIsFinite) {
              node.hidden = false;
              if (!this.nodeDepths.has(node.id)) {
                this.nodeDepths.set(node.id, 0);
              }
              node.depth = this.nodeDepths.get(node.id);
              return;
            }

            const depth = this.nodeDepths.get(node.id);
            const numericDepth = typeof depth === "number" ? depth : Infinity;
            node.depth = numericDepth;
            node.hidden = numericDepth > limit;
          });

          this.links.forEach((link) => {
            if (!hasFocus || !limitIsFinite) {
              link.hidden = false;
              return;
            }

            const sourceId = this.getNodeIdFromLink(link, "source");
            const targetId = this.getNodeIdFromLink(link, "target");

            link.hidden = this.isNodeHidden(sourceId) || this.isNodeHidden(targetId);
          });

          if (this.activeNodeId) {
            const activeNode = this.nodeIndex.get(this.activeNodeId);
            if (!activeNode || activeNode.hidden) {
              if (this.focusNodeId && !this.isNodeHidden(this.focusNodeId)) {
                this.activeNodeId = this.focusNodeId;
              } else {
                this.activeNodeId = null;
              }
            }
          }
        }

        syncDepths() {
          this.recalculateDepths();
          this.applyDepthLimit();
          this.update();

          if (this.activeNodeId) {
            this.setActiveNode(this.activeNodeId);
          } else if (this.focusNodeId && !this.isNodeHidden(this.focusNodeId)) {
            this.setActiveNode(this.focusNodeId);
          } else {
            renderNodeDetails(null);
          }
        }

        setFocusNode(nodeId) {
          this.focusNodeId = nodeId || null;
          this.syncDepths();
        }

        setDepthLimit(limit, options = {}) {
          const parsed = Number(limit);
          const sanitized = Number.isFinite(parsed) ? Math.max(0, Math.floor(parsed)) : 0;

          if (this.depthLimit === sanitized && !options.force) {
            return this.depthLimit;
          }

          this.depthLimit = sanitized;

          if (options.skipSync) {
            return this.depthLimit;
          }

          this.syncDepths();

          return this.depthLimit;
        }

        setNodeClickHandler(handler) {
          this.handleNodeClick = handler;
          this.update();
        }

        update() {
          const d3 = this.d3;

          const visibleNodes = this.nodes.filter((node) => !node.hidden);
          const visibleLinks = this.links.filter((link) => !link.hidden);

          this.linkElements = this.linkGroup
            .selectAll("line.graph-link")
            .data(visibleLinks, (d) => d.key);

          this.linkElements.exit().remove();

          const linkEnter = this.linkElements.enter().append("line").attr("class", "graph-link");
          linkEnter.append("title");

          this.linkElements = linkEnter.merge(this.linkElements);
          this.linkElements.select("title").text((d) => formatRelationshipType(d.type));

          this.linkLabelElements = this.labelGroup
            .selectAll("text.graph-link-label")
            .data(visibleLinks, (d) => d.key);

          this.linkLabelElements.exit().remove();

          const labelEnter = this.linkLabelElements
            .enter()
            .append("text")
            .attr("class", "graph-link-label")
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "middle");

          this.linkLabelElements = labelEnter.merge(this.linkLabelElements);
          this.linkLabelElements.text((d) => formatRelationshipType(d.type));

          this.nodeElements = this.nodeGroup
            .selectAll("g.graph-node")
            .data(visibleNodes, (d) => d.id);

          this.nodeElements.exit().remove();

          const nodeEnter = this.nodeElements
            .enter()
            .append("g")
            .attr("class", "graph-node")
            .attr("tabindex", 0)
            .attr("role", "button")
            .call(this.dragBehavior);

          nodeEnter.append("circle").attr("r", 32);

          nodeEnter
            .append("text")
            .attr("dy", 4)
            .text((d) => d.displayName);

          nodeEnter.append("title");

          this.nodeElements = nodeEnter.merge(this.nodeElements);

          this.nodeElements.select("text").text((d) => d.displayName);
          this.nodeElements.select("title").text((d) => d.tooltip || d.displayName || d.id);

          this.nodeElements.on("click", (event, d) => {
            event.stopPropagation();
            if (this.handleNodeClick) {
              this.handleNodeClick(d);
            }
          });

          this.nodeElements.on("keydown", (event, d) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              if (this.handleNodeClick) {
                this.handleNodeClick(d);
              }
            }
          });

          this.refreshNodeState();

          if (visibleNodes.length) {
            this.simulation.nodes(visibleNodes);
            this.simulation.force("link").links(visibleLinks);
            this.simulation.alpha(0.9).restart();
          } else {
            this.simulation.stop();
          }
      }
    }

    graphExplorer = new GraphExplorer(graphContainer);
    graphExplorer.setDepthLimit(activeHopLimit, { skipSync: true });
    renderNodeDetails(null);

      const loadNeighborsForNode = async (node, options = {}) => {
        const {
          announceIfLoaded = true,
          setFocus = false,
          skipEnsure = false,
          suppressStatus = false,
          setActive = true,
        } = options;

        const formatted = formatNode(node);
        const nodeId = formatted.elementId;
        const displayName = formatted.displayName;

        graphExplorer.addOrUpdateNode(formatted, { skipUpdate: true });

        if (setFocus) {
          graphExplorer.setFocusNode(nodeId);
        }

        if (setActive) {
          graphExplorer.setActiveNode(nodeId);
        }

        if (graphExplorer.isNodeLoaded(nodeId)) {
          if (!skipEnsure) {
            await ensureNeighborhoodLoaded(nodeId, activeHopLimit);
          }

          if (announceIfLoaded && !suppressStatus) {
            setGraphStatus(`${displayName} is already expanded.`);
          }

          return;
        }

        if (!suppressStatus) {
          setGraphStatus(`Loading relationships for ${displayName}…`);
        }

        try {
          const result = await runNeo4jQuery(
            `
              MATCH (n)
              WHERE elementId(n) = $elementId
              OPTIONAL MATCH (n)-[r]-(m)
              RETURN n, r, m
            `,
            { elementId: nodeId }
          );

          let newConnections = 0;

          result.records.forEach((record) => {
            const rootNode = formatNode(record.get("n"));
            graphExplorer.addOrUpdateNode(rootNode, { skipUpdate: true });

            const relatedNode = record.get("m");
            const relationship = record.get("r");

            if (relatedNode) {
              const formattedNeighbor = formatNode(relatedNode);
              graphExplorer.addOrUpdateNode(formattedNeighbor, { skipUpdate: true });

              const relationshipType = relationship && relationship.type ? relationship.type : "RELATED";
              const relationshipId =
                relationship &&
                (typeof relationship.elementId === "function"
                  ? relationship.elementId()
                  : relationship.elementId);

              const added = graphExplorer.addLink(
                rootNode.elementId,
                formattedNeighbor.elementId,
                relationshipType,
                relationshipId || undefined,
                { skipUpdate: true }
              );

              if (added) {
                newConnections += 1;
              }
            }
          });

          graphExplorer.markNodeLoaded(nodeId);
          graphExplorer.syncDepths();

          const visibleConnections = graphExplorer.countConnections(nodeId);
          const totalConnections = graphExplorer.countConnections(nodeId, { includeHidden: true });
          const hiddenConnections = Math.max(0, totalConnections - visibleConnections);

          if (!skipEnsure) {
            await ensureNeighborhoodLoaded(nodeId, activeHopLimit);
          }

          if (!newConnections) {
            if (hiddenConnections > 0) {
              if (!suppressStatus) {
                setGraphStatus(
                  `No new visible nodes for ${displayName}. ${visibleConnections} connection${visibleConnections === 1 ? "" : "s"} in view, ${hiddenConnections} hidden beyond hop limit.`
                );
              }
            } else {
              if (!suppressStatus) {
                setGraphStatus(`No related nodes found for ${displayName}.`);
              }
            }
          } else {
            let message = `Loaded ${newConnections} connection${newConnections === 1 ? "" : "s"} for ${displayName}. ${visibleConnections} total in view.`;

            if (hiddenConnections > 0) {
              message += ` ${hiddenConnections} hidden beyond hop limit.`;
            }

            if (!suppressStatus) {
              setGraphStatus(message);
            }
          }
        } catch (error) {
          console.error("Failed to load relationships", error);
          if (!suppressStatus) {
            setGraphStatus(`Unable to load relationships: ${error.message || error}`, true);
          }
        }
      };

      const ensureNeighborhoodLoaded = async (focusNodeId, hopLimit) => {
        if (!graphExplorer || focusNodeId == null) {
          return;
        }

        const parsedLimit = Number(hopLimit);
        const limit = Number.isFinite(parsedLimit) ? Math.max(0, Math.floor(parsedLimit)) : 0;

        if (limit <= 0) {
          return;
        }

        const visited = new Set();
        const queue = [{ id: String(focusNodeId), depth: 0 }];

        while (queue.length) {
          const { id, depth } = queue.shift();

          if (!id || visited.has(id)) {
            continue;
          }

          visited.add(id);

          const node = graphExplorer.getNode(id);

          if (!node) {
            continue;
          }

          if (depth < limit && !graphExplorer.isNodeLoaded(id)) {
            try {
              await loadNeighborsForNode(node, {
                announceIfLoaded: false,
                setFocus: false,
                skipEnsure: true,
                suppressStatus: true,
                setActive: false,
              });
            } catch (error) {
              console.error(`Failed to pre-load neighborhood for ${id}`, error);
              continue;
            }
          }

          if (depth >= limit) {
            continue;
          }

          const neighborIds = graphExplorer.getNeighborIds(id, { includeHidden: true });

          neighborIds.forEach((neighborId) => {
            if (!visited.has(neighborId)) {
              queue.push({ id: neighborId, depth: depth + 1 });
            }
          });
        }
      };

      const openGraphWithRoot = (node, labelFallback) => {
        if (!node) {
          return;
        }

        const formatted = formatNode(node);
        graphExplorer.reset();
        graphExplorer.addOrUpdateNode(formatted, { skipUpdate: true });
        graphExplorer.setFocusNode(formatted.elementId);
        setGraphStatus(`Exploring ${labelFallback || formatted.displayName}.`);

        loadNeighborsForNode(formatted, { announceIfLoaded: false }).catch((error) => {
          console.error("Failed to initialize graph", error);
        });

        if (typeof graphContainer.scrollIntoView === "function") {
          graphContainer.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      };

      graphExplorer.setNodeClickHandler((node) => {
        loadNeighborsForNode(node, { setFocus: true }).catch((error) => {
          console.error("Failed to expand node", error);
        });
      });

      const fetchNodes = async () => {
        setLoading(true);
        setStatus("Connecting to Neo4j Aura…");

        try {
          const result = await runNeo4jQuery("MATCH (n) RETURN n LIMIT 100");
          renderNodes(result.records);
          setStatus(`Fetched ${result.records.length} node${result.records.length === 1 ? "" : "s"}.`);
        } catch (error) {
          console.error("Failed to fetch nodes", error);
          setStatus(`Unable to load nodes: ${error.message || error}`, true);
          renderEmptyState();
          setGraphStatus("Select a node from the table to explore its relationships.");
        } finally {
          setLoading(false);
        }
      };

      reloadButton.addEventListener("click", () => {
        fetchNodes();
      });

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", fetchNodes, { once: true });
      } else {
        fetchNodes();
      }
    })();
  </script>
</body>
</html>
